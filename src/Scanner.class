 // Failed to get sources. Instead, stub sources have been generated by the disassembler.
 // Implementation of methods is unavailable.
package java.util;
public final class Scanner implements java.util.Iterator, java.io.Closeable {
  
  private java.nio.CharBuffer buf;
  
  private static final int BUFFER_SIZE = 1024;
  
  private int position;
  
  private java.util.regex.Matcher matcher;
  
  private java.util.regex.Pattern delimPattern;
  
  private java.util.regex.Pattern hasNextPattern;
  
  private int hasNextPosition;
  
  private java.lang.String hasNextResult;
  
  private java.lang.Readable source;
  
  private boolean sourceClosed;
  
  private boolean needInput;
  
  private boolean skipped;
  
  private int savedScannerPosition;
  
  private java.lang.Object typeCache;
  
  private boolean matchValid;
  
  private boolean closed;
  
  private int radix;
  
  private int defaultRadix;
  
  private java.util.Locale locale;
  
  private java.util.Scanner$PatternLRUCache patternCache;
  
  private java.io.IOException lastException;
  
  int modCount;
  
  private static java.util.regex.Pattern WHITESPACE_PATTERN;
  
  private static java.util.regex.Pattern FIND_ANY_PATTERN;
  
  private static java.util.regex.Pattern NON_ASCII_DIGIT;
  
  private java.lang.String groupSeparator;
  
  private java.lang.String decimalSeparator;
  
  private java.lang.String nanString;
  
  private java.lang.String infinityString;
  
  private java.lang.String positivePrefix;
  
  private java.lang.String negativePrefix;
  
  private java.lang.String positiveSuffix;
  
  private java.lang.String negativeSuffix;
  
  private static volatile java.util.regex.Pattern boolPattern;
  
  private static final java.lang.String BOOLEAN_PATTERN = "true|false";
  
  private java.util.regex.Pattern integerPattern;
  
  private java.lang.String digits;
  
  private java.lang.String non0Digit;
  
  private int SIMPLE_GROUP_INDEX;
  
  private static volatile java.util.regex.Pattern separatorPattern;
  
  private static volatile java.util.regex.Pattern linePattern;
  
  private static final java.lang.String LINE_SEPARATOR_PATTERN = "\r\n|[\n\r  ]";
  
  private static final java.lang.String LINE_PATTERN = ".*(\r\n|[\n\r  ])|.+$";
  
  private java.util.regex.Pattern floatPattern;
  
  private java.util.regex.Pattern decimalPattern;
  
  static final boolean $assertionsDisabled;
  
  private static java.util.regex.Pattern boolPattern() {
    return null;
  }
  
  private java.lang.String buildIntegerPatternString() {
    return null;
  }
  
  private java.util.regex.Pattern integerPattern() {
    return null;
  }
  
  private static java.util.regex.Pattern separatorPattern() {
    return null;
  }
  
  private static java.util.regex.Pattern linePattern() {
    return null;
  }
  
  private void buildFloatAndDecimalPattern() {
  }
  
  private java.util.regex.Pattern floatPattern() {
    return null;
  }
  
  private java.util.regex.Pattern decimalPattern() {
    return null;
  }
  
  private Scanner(java.lang.Readable source, java.util.regex.Pattern pattern) {
  }
  
  public Scanner(java.lang.Readable source) {
  }
  
  public Scanner(java.io.InputStream source) {
  }
  
  public Scanner(java.io.InputStream source, java.lang.String charsetName) {
  }
  
  public Scanner(java.io.InputStream source, java.nio.charset.Charset charset) {
  }
  
  private static java.nio.charset.Charset toCharset(java.lang.String csn) {
    return null;
  }
  
  private static java.lang.Readable makeReadable(java.nio.file.Path source, java.nio.charset.Charset charset) throws java.io.IOException {
    return null;
  }
  
  private static java.lang.Readable makeReadable(java.io.InputStream source, java.nio.charset.Charset charset) {
    return null;
  }
  
  public Scanner(java.io.File source) throws java.io.FileNotFoundException {
  }
  
  public Scanner(java.io.File source, java.lang.String charsetName) throws java.io.FileNotFoundException {
  }
  
  public Scanner(java.io.File source, java.nio.charset.Charset charset) throws java.io.IOException {
  }
  
  private Scanner(java.io.File source, java.nio.charset.CharsetDecoder dec) throws java.io.FileNotFoundException {
  }
  
  private static java.nio.charset.CharsetDecoder toDecoder(java.lang.String charsetName) {
    return null;
  }
  
  private static java.lang.Readable makeReadable(java.nio.channels.ReadableByteChannel source, java.nio.charset.CharsetDecoder dec) {
    return null;
  }
  
  private static java.lang.Readable makeReadable(java.nio.channels.ReadableByteChannel source, java.nio.charset.Charset charset) {
    return null;
  }
  
  public Scanner(java.nio.file.Path source) throws java.io.IOException {
  }
  
  public Scanner(java.nio.file.Path source, java.lang.String charsetName) throws java.io.IOException {
  }
  
  public Scanner(java.nio.file.Path source, java.nio.charset.Charset charset) throws java.io.IOException {
  }
  
  public Scanner(java.lang.String source) {
  }
  
  public Scanner(java.nio.channels.ReadableByteChannel source) {
  }
  
  private static java.lang.Readable makeReadable(java.nio.channels.ReadableByteChannel source) {
    return null;
  }
  
  public Scanner(java.nio.channels.ReadableByteChannel source, java.lang.String charsetName) {
  }
  
  public Scanner(java.nio.channels.ReadableByteChannel source, java.nio.charset.Charset charset) {
  }
  
  private void saveState() {
  }
  
  private void revertState() {
  }
  
  private boolean revertState(boolean b) {
    return false;
  }
  
  private void cacheResult() {
  }
  
  private void cacheResult(java.lang.String result) {
  }
  
  private void clearCaches() {
  }
  
  private java.lang.String getCachedResult() {
    return null;
  }
  
  private void useTypeCache() {
  }
  
  private void readInput() {
  }
  
  private boolean makeSpace() {
    return false;
  }
  
  private void translateSavedIndexes(int offset) {
  }
  
  private void throwFor() {
  }
  
  private boolean hasTokenInBuffer() {
    return false;
  }
  
  private java.lang.String getCompleteTokenInBuffer(java.util.regex.Pattern pattern) {
    return null;
  }
  
  private boolean findPatternInBuffer(java.util.regex.Pattern pattern, int horizon) {
    return false;
  }
  
  private boolean matchPatternInBuffer(java.util.regex.Pattern pattern) {
    return false;
  }
  
  private void ensureOpen() {
  }
  
  public void close() {
  }
  
  public java.io.IOException ioException() {
    return null;
  }
  
  public java.util.regex.Pattern delimiter() {
    return null;
  }
  
  public java.util.Scanner useDelimiter(java.util.regex.Pattern pattern) {
    return null;
  }
  
  public java.util.Scanner useDelimiter(java.lang.String pattern) {
    return null;
  }
  
  public java.util.Locale locale() {
    return null;
  }
  
  public java.util.Scanner useLocale(java.util.Locale locale) {
    return null;
  }
  
  public int radix() {
    return 0;
  }
  
  public java.util.Scanner useRadix(int radix) {
    return null;
  }
  
  private void setRadix(int radix) {
  }
  
  public java.util.regex.MatchResult match() {
    return null;
  }
  
  public java.lang.String toString() {
    return null;
  }
  
  public boolean hasNext() {
    return false;
  }
  
  public java.lang.String next() {
    return null;
  }
  
  public void remove() {
  }
  
  public boolean hasNext(java.lang.String pattern) {
    return false;
  }
  
  public java.lang.String next(java.lang.String pattern) {
    return null;
  }
  
  public boolean hasNext(java.util.regex.Pattern pattern) {
    return false;
  }
  
  public java.lang.String next(java.util.regex.Pattern pattern) {
    return null;
  }
  
  public boolean hasNextLine() {
    return false;
  }
  
  public java.lang.String nextLine() {
    return null;
  }
  
  public java.lang.String findInLine(java.lang.String pattern) {
    return null;
  }
  
  public java.lang.String findInLine(java.util.regex.Pattern pattern) {
    return null;
  }
  
  public java.lang.String findWithinHorizon(java.lang.String pattern, int horizon) {
    return null;
  }
  
  public java.lang.String findWithinHorizon(java.util.regex.Pattern pattern, int horizon) {
    return null;
  }
  
  public java.util.Scanner skip(java.util.regex.Pattern pattern) {
    return null;
  }
  
  public java.util.Scanner skip(java.lang.String pattern) {
    return null;
  }
  
  public boolean hasNextBoolean() {
    return false;
  }
  
  public boolean nextBoolean() {
    return false;
  }
  
  public boolean hasNextByte() {
    return false;
  }
  
  public boolean hasNextByte(int radix) {
    return false;
  }
  
  public byte nextByte() {
    return 0;
  }
  
  public byte nextByte(int radix) {
    return 0;
  }
  
  public boolean hasNextShort() {
    return false;
  }
  
  public boolean hasNextShort(int radix) {
    return false;
  }
  
  public short nextShort() {
    return 0;
  }
  
  public short nextShort(int radix) {
    return 0;
  }
  
  public boolean hasNextInt() {
    return false;
  }
  
  public boolean hasNextInt(int radix) {
    return false;
  }
  
  private java.lang.String processIntegerToken(java.lang.String token) {
    return null;
  }
  
  public int nextInt() {
    return 0;
  }
  
  public int nextInt(int radix) {
    return 0;
  }
  
  public boolean hasNextLong() {
    return false;
  }
  
  public boolean hasNextLong(int radix) {
    return false;
  }
  
  public long nextLong() {
    return 0;
  }
  
  public long nextLong(int radix) {
    return 0;
  }
  
  private java.lang.String processFloatToken(java.lang.String token) {
    return null;
  }
  
  public boolean hasNextFloat() {
    return false;
  }
  
  public float nextFloat() {
    return 0;
  }
  
  public boolean hasNextDouble() {
    return false;
  }
  
  public double nextDouble() {
    return 0;
  }
  
  public boolean hasNextBigInteger() {
    return false;
  }
  
  public boolean hasNextBigInteger(int radix) {
    return false;
  }
  
  public java.math.BigInteger nextBigInteger() {
    return null;
  }
  
  public java.math.BigInteger nextBigInteger(int radix) {
    return null;
  }
  
  public boolean hasNextBigDecimal() {
    return false;
  }
  
  public java.math.BigDecimal nextBigDecimal() {
    return null;
  }
  
  public java.util.Scanner reset() {
    return null;
  }
  
  public  java.util.stream.Stream<java.lang.String> tokens() {
    return null;
  }
  
  public  java.util.stream.Stream<java.util.regex.MatchResult> findAll(java.util.regex.Pattern pattern) {
    return null;
  }
  
  public  java.util.stream.Stream<java.util.regex.MatchResult> findAll(java.lang.String patString) {
    return null;
  }
  
  public bridge java.lang.Object next() {
    return null;
  }
  
  static {} {
  }
}